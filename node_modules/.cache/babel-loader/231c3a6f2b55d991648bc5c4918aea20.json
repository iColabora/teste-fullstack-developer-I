{"ast":null,"code":"import { RX_ENCODED_COMMA, RX_ENCODE_REVERSE, RX_PLUS, RX_QUERY_START } from '../constants/regex';\nimport { isTag } from './dom';\nimport { isArray, isNull, isPlainObject, isString, isUndefined } from './inspect';\nimport { keys } from './object';\nimport { toString } from './string';\nvar ANCHOR_TAG = 'a'; // Method to replace reserved chars\n\nvar encodeReserveReplacer = function encodeReserveReplacer(c) {\n  return '%' + c.charCodeAt(0).toString(16);\n}; // Fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\n\n\nvar encode = function encode(str) {\n  return encodeURIComponent(toString(str)).replace(RX_ENCODE_REVERSE, encodeReserveReplacer).replace(RX_ENCODED_COMMA, ',');\n};\n\nvar decode = decodeURIComponent; // Stringifies an object of query parameters\n// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js\n\nexport var stringifyQueryObj = function stringifyQueryObj(obj) {\n  if (!isPlainObject(obj)) {\n    return '';\n  }\n\n  var query = keys(obj).map(function (key) {\n    var value = obj[key];\n\n    if (isUndefined(value)) {\n      return '';\n    } else if (isNull(value)) {\n      return encode(key);\n    } else if (isArray(value)) {\n      return value.reduce(function (results, value2) {\n        if (isNull(value2)) {\n          results.push(encode(key));\n        } else if (!isUndefined(value2)) {\n          // Faster than string interpolation\n          results.push(encode(key) + '=' + encode(value2));\n        }\n\n        return results;\n      }, []).join('&');\n    } // Faster than string interpolation\n\n\n    return encode(key) + '=' + encode(value);\n  })\n  /* must check for length, as we only want to filter empty strings, not things that look falsey! */\n  .filter(function (x) {\n    return x.length > 0;\n  }).join('&');\n  return query ? \"?\".concat(query) : '';\n};\nexport var parseQuery = function parseQuery(query) {\n  var parsed = {};\n  query = toString(query).trim().replace(RX_QUERY_START, '');\n\n  if (!query) {\n    return parsed;\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(RX_PLUS, ' ').split('=');\n    var key = decode(parts.shift());\n    var value = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if (isUndefined(parsed[key])) {\n      parsed[key] = value;\n    } else if (isArray(parsed[key])) {\n      parsed[key].push(value);\n    } else {\n      parsed[key] = [parsed[key], value];\n    }\n  });\n  return parsed;\n};\nexport var isLink = function isLink(props) {\n  return !!(props.href || props.to);\n};\nexport var isRouterLink = function isRouterLink(tag) {\n  return !!(tag && !isTag(tag, 'a'));\n};\nexport var computeTag = function computeTag(_ref, thisOrParent) {\n  var to = _ref.to,\n      disabled = _ref.disabled,\n      routerComponentName = _ref.routerComponentName;\n  var hasRouter = !!thisOrParent.$router;\n\n  if (!hasRouter || hasRouter && (disabled || !to)) {\n    return ANCHOR_TAG;\n  } // TODO:\n  //   Check registered components for existence of user supplied router link component name\n  //   We would need to check PascalCase, kebab-case, and camelCase versions of name:\n  //   const name = routerComponentName\n  //   const names = [name, PascalCase(name), KebabCase(name), CamelCase(name)]\n  //   exists = names.some(name => !!thisOrParent.$options.components[name])\n  //   And may want to cache the result for performance or we just let the render fail\n  //   if the component is not registered\n\n\n  return routerComponentName || (thisOrParent.$nuxt ? 'nuxt-link' : 'router-link');\n};\nexport var computeRel = function computeRel() {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      target = _ref2.target,\n      rel = _ref2.rel;\n\n  return target === '_blank' && isNull(rel) ? 'noopener' : rel || null;\n};\nexport var computeHref = function computeHref() {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      href = _ref3.href,\n      to = _ref3.to;\n\n  var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCHOR_TAG;\n  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#';\n  var toFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/'; // Return `href` when explicitly provided\n\n  if (href) {\n    return href;\n  } // We've checked for `$router` in `computeTag()`, so `isRouterLink()` indicates a live router\n  // When deferring to Vue Router's `<router-link>`, don't use the `href` attribute at all\n  // We return `null`, and then remove `href` from the attributes passed to `<router-link>`\n\n\n  if (isRouterLink(tag)) {\n    return null;\n  } // Fallback to `to` prop (if `to` is a string)\n\n\n  if (isString(to)) {\n    return to || toFallback;\n  } // Fallback to `to.path' + `to.query` + `to.hash` prop (if `to` is an object)\n\n\n  if (isPlainObject(to) && (to.path || to.query || to.hash)) {\n    var path = toString(to.path);\n    var query = stringifyQueryObj(to.query);\n    var hash = toString(to.hash);\n    hash = !hash || hash.charAt(0) === '#' ? hash : \"#\".concat(hash);\n    return \"\".concat(path).concat(query).concat(hash) || toFallback;\n  } // If nothing is provided return the fallback\n\n\n  return fallback;\n};","map":{"version":3,"names":["RX_ENCODED_COMMA","RX_ENCODE_REVERSE","RX_PLUS","RX_QUERY_START","isTag","isArray","isNull","isPlainObject","isString","isUndefined","keys","toString","ANCHOR_TAG","encodeReserveReplacer","c","charCodeAt","encode","str","encodeURIComponent","replace","decode","decodeURIComponent","stringifyQueryObj","obj","query","map","key","value","reduce","results","value2","push","join","filter","x","length","concat","parseQuery","parsed","trim","split","forEach","param","parts","shift","isLink","props","href","to","isRouterLink","tag","computeTag","_ref","thisOrParent","disabled","routerComponentName","hasRouter","$router","$nuxt","computeRel","_ref2","arguments","undefined","target","rel","computeHref","_ref3","fallback","toFallback","path","hash","charAt"],"sources":["C:/Users/rayss/dev-fullstack-i/node_modules/bootstrap-vue/esm/utils/router.js"],"sourcesContent":["import { RX_ENCODED_COMMA, RX_ENCODE_REVERSE, RX_PLUS, RX_QUERY_START } from '../constants/regex';\nimport { isTag } from './dom';\nimport { isArray, isNull, isPlainObject, isString, isUndefined } from './inspect';\nimport { keys } from './object';\nimport { toString } from './string';\nvar ANCHOR_TAG = 'a'; // Method to replace reserved chars\n\nvar encodeReserveReplacer = function encodeReserveReplacer(c) {\n  return '%' + c.charCodeAt(0).toString(16);\n}; // Fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\n\n\nvar encode = function encode(str) {\n  return encodeURIComponent(toString(str)).replace(RX_ENCODE_REVERSE, encodeReserveReplacer).replace(RX_ENCODED_COMMA, ',');\n};\n\nvar decode = decodeURIComponent; // Stringifies an object of query parameters\n// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js\n\nexport var stringifyQueryObj = function stringifyQueryObj(obj) {\n  if (!isPlainObject(obj)) {\n    return '';\n  }\n\n  var query = keys(obj).map(function (key) {\n    var value = obj[key];\n\n    if (isUndefined(value)) {\n      return '';\n    } else if (isNull(value)) {\n      return encode(key);\n    } else if (isArray(value)) {\n      return value.reduce(function (results, value2) {\n        if (isNull(value2)) {\n          results.push(encode(key));\n        } else if (!isUndefined(value2)) {\n          // Faster than string interpolation\n          results.push(encode(key) + '=' + encode(value2));\n        }\n\n        return results;\n      }, []).join('&');\n    } // Faster than string interpolation\n\n\n    return encode(key) + '=' + encode(value);\n  })\n  /* must check for length, as we only want to filter empty strings, not things that look falsey! */\n  .filter(function (x) {\n    return x.length > 0;\n  }).join('&');\n  return query ? \"?\".concat(query) : '';\n};\nexport var parseQuery = function parseQuery(query) {\n  var parsed = {};\n  query = toString(query).trim().replace(RX_QUERY_START, '');\n\n  if (!query) {\n    return parsed;\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(RX_PLUS, ' ').split('=');\n    var key = decode(parts.shift());\n    var value = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if (isUndefined(parsed[key])) {\n      parsed[key] = value;\n    } else if (isArray(parsed[key])) {\n      parsed[key].push(value);\n    } else {\n      parsed[key] = [parsed[key], value];\n    }\n  });\n  return parsed;\n};\nexport var isLink = function isLink(props) {\n  return !!(props.href || props.to);\n};\nexport var isRouterLink = function isRouterLink(tag) {\n  return !!(tag && !isTag(tag, 'a'));\n};\nexport var computeTag = function computeTag(_ref, thisOrParent) {\n  var to = _ref.to,\n      disabled = _ref.disabled,\n      routerComponentName = _ref.routerComponentName;\n  var hasRouter = !!thisOrParent.$router;\n\n  if (!hasRouter || hasRouter && (disabled || !to)) {\n    return ANCHOR_TAG;\n  } // TODO:\n  //   Check registered components for existence of user supplied router link component name\n  //   We would need to check PascalCase, kebab-case, and camelCase versions of name:\n  //   const name = routerComponentName\n  //   const names = [name, PascalCase(name), KebabCase(name), CamelCase(name)]\n  //   exists = names.some(name => !!thisOrParent.$options.components[name])\n  //   And may want to cache the result for performance or we just let the render fail\n  //   if the component is not registered\n\n\n  return routerComponentName || (thisOrParent.$nuxt ? 'nuxt-link' : 'router-link');\n};\nexport var computeRel = function computeRel() {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      target = _ref2.target,\n      rel = _ref2.rel;\n\n  return target === '_blank' && isNull(rel) ? 'noopener' : rel || null;\n};\nexport var computeHref = function computeHref() {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      href = _ref3.href,\n      to = _ref3.to;\n\n  var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCHOR_TAG;\n  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#';\n  var toFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';\n\n  // Return `href` when explicitly provided\n  if (href) {\n    return href;\n  } // We've checked for `$router` in `computeTag()`, so `isRouterLink()` indicates a live router\n  // When deferring to Vue Router's `<router-link>`, don't use the `href` attribute at all\n  // We return `null`, and then remove `href` from the attributes passed to `<router-link>`\n\n\n  if (isRouterLink(tag)) {\n    return null;\n  } // Fallback to `to` prop (if `to` is a string)\n\n\n  if (isString(to)) {\n    return to || toFallback;\n  } // Fallback to `to.path' + `to.query` + `to.hash` prop (if `to` is an object)\n\n\n  if (isPlainObject(to) && (to.path || to.query || to.hash)) {\n    var path = toString(to.path);\n    var query = stringifyQueryObj(to.query);\n    var hash = toString(to.hash);\n    hash = !hash || hash.charAt(0) === '#' ? hash : \"#\".concat(hash);\n    return \"\".concat(path).concat(query).concat(hash) || toFallback;\n  } // If nothing is provided return the fallback\n\n\n  return fallback;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}