{"ast":null,"code":"/*! \n * portal-vue © Thorsten Lünborg, 2019 \n * \n * Version: 2.1.7\n * \n * LICENCE: MIT \n * \n * https://github.com/linusborg/portal-vue\n * \n*/\n'use strict';\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar Vue = _interopDefault(require('vue'));\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar inBrowser = typeof window !== 'undefined';\n\nfunction freeze(item) {\n  if (Array.isArray(item) || _typeof(item) === 'object') {\n    return Object.freeze(item);\n  }\n\n  return item;\n}\n\nfunction combinePassengers(transports) {\n  var slotProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return transports.reduce(function (passengers, transport) {\n    var temp = transport.passengers[0];\n    var newPassengers = typeof temp === 'function' ? temp(slotProps) : transport.passengers;\n    return passengers.concat(newPassengers);\n  }, []);\n}\n\nfunction stableSort(array, compareFn) {\n  return array.map(function (v, idx) {\n    return [idx, v];\n  }).sort(function (a, b) {\n    return compareFn(a[1], b[1]) || a[0] - b[0];\n  }).map(function (c) {\n    return c[1];\n  });\n}\n\nfunction pick(obj, keys) {\n  return keys.reduce(function (acc, key) {\n    if (obj.hasOwnProperty(key)) {\n      acc[key] = obj[key];\n    }\n\n    return acc;\n  }, {});\n}\n\nvar transports = {};\nvar targets = {};\nvar sources = {};\nvar Wormhole = Vue.extend({\n  data: function data() {\n    return {\n      transports: transports,\n      targets: targets,\n      sources: sources,\n      trackInstances: inBrowser\n    };\n  },\n  methods: {\n    open: function open(transport) {\n      if (!inBrowser) return;\n      var to = transport.to,\n          from = transport.from,\n          passengers = transport.passengers,\n          _transport$order = transport.order,\n          order = _transport$order === void 0 ? Infinity : _transport$order;\n      if (!to || !from || !passengers) return;\n      var newTransport = {\n        to: to,\n        from: from,\n        passengers: freeze(passengers),\n        order: order\n      };\n      var keys = Object.keys(this.transports);\n\n      if (keys.indexOf(to) === -1) {\n        Vue.set(this.transports, to, []);\n      }\n\n      var currentIndex = this.$_getTransportIndex(newTransport); // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays\n\n      var newTransports = this.transports[to].slice(0);\n\n      if (currentIndex === -1) {\n        newTransports.push(newTransport);\n      } else {\n        newTransports[currentIndex] = newTransport;\n      }\n\n      this.transports[to] = stableSort(newTransports, function (a, b) {\n        return a.order - b.order;\n      });\n    },\n    close: function close(transport) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var to = transport.to,\n          from = transport.from;\n      if (!to || !from && force === false) return;\n\n      if (!this.transports[to]) {\n        return;\n      }\n\n      if (force) {\n        this.transports[to] = [];\n      } else {\n        var index = this.$_getTransportIndex(transport);\n\n        if (index >= 0) {\n          // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays\n          var newTransports = this.transports[to].slice(0);\n          newTransports.splice(index, 1);\n          this.transports[to] = newTransports;\n        }\n      }\n    },\n    registerTarget: function registerTarget(target, vm, force) {\n      if (!inBrowser) return;\n\n      if (this.trackInstances && !force && this.targets[target]) {\n        console.warn(\"[portal-vue]: Target \".concat(target, \" already exists\"));\n      }\n\n      this.$set(this.targets, target, Object.freeze([vm]));\n    },\n    unregisterTarget: function unregisterTarget(target) {\n      this.$delete(this.targets, target);\n    },\n    registerSource: function registerSource(source, vm, force) {\n      if (!inBrowser) return;\n\n      if (this.trackInstances && !force && this.sources[source]) {\n        console.warn(\"[portal-vue]: source \".concat(source, \" already exists\"));\n      }\n\n      this.$set(this.sources, source, Object.freeze([vm]));\n    },\n    unregisterSource: function unregisterSource(source) {\n      this.$delete(this.sources, source);\n    },\n    hasTarget: function hasTarget(to) {\n      return !!(this.targets[to] && this.targets[to][0]);\n    },\n    hasSource: function hasSource(to) {\n      return !!(this.sources[to] && this.sources[to][0]);\n    },\n    hasContentFor: function hasContentFor(to) {\n      return !!this.transports[to] && !!this.transports[to].length;\n    },\n    // Internal\n    $_getTransportIndex: function $_getTransportIndex(_ref) {\n      var to = _ref.to,\n          from = _ref.from;\n\n      for (var i in this.transports[to]) {\n        if (this.transports[to][i].from === from) {\n          return +i;\n        }\n      }\n\n      return -1;\n    }\n  }\n});\nvar wormhole = new Wormhole(transports);\nvar _id = 1;\nvar Portal = Vue.extend({\n  name: 'portal',\n  props: {\n    disabled: {\n      type: Boolean\n    },\n    name: {\n      type: String,\n      default: function _default() {\n        return String(_id++);\n      }\n    },\n    order: {\n      type: Number,\n      default: 0\n    },\n    slim: {\n      type: Boolean\n    },\n    slotProps: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    tag: {\n      type: String,\n      default: 'DIV'\n    },\n    to: {\n      type: String,\n      default: function _default() {\n        return String(Math.round(Math.random() * 10000000));\n      }\n    }\n  },\n  created: function created() {\n    var _this = this;\n\n    this.$nextTick(function () {\n      wormhole.registerSource(_this.name, _this);\n    });\n  },\n  mounted: function mounted() {\n    if (!this.disabled) {\n      this.sendUpdate();\n    }\n  },\n  updated: function updated() {\n    if (this.disabled) {\n      this.clear();\n    } else {\n      this.sendUpdate();\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    wormhole.unregisterSource(this.name);\n    this.clear();\n  },\n  watch: {\n    to: function to(newValue, oldValue) {\n      oldValue && oldValue !== newValue && this.clear(oldValue);\n      this.sendUpdate();\n    }\n  },\n  methods: {\n    clear: function clear(target) {\n      var closer = {\n        from: this.name,\n        to: target || this.to\n      };\n      wormhole.close(closer);\n    },\n    normalizeSlots: function normalizeSlots() {\n      return this.$scopedSlots.default ? [this.$scopedSlots.default] : this.$slots.default;\n    },\n    normalizeOwnChildren: function normalizeOwnChildren(children) {\n      return typeof children === 'function' ? children(this.slotProps) : children;\n    },\n    sendUpdate: function sendUpdate() {\n      var slotContent = this.normalizeSlots();\n\n      if (slotContent) {\n        var transport = {\n          from: this.name,\n          to: this.to,\n          passengers: _toConsumableArray(slotContent),\n          order: this.order\n        };\n        wormhole.open(transport);\n      } else {\n        this.clear();\n      }\n    }\n  },\n  render: function render(h) {\n    var children = this.$slots.default || this.$scopedSlots.default || [];\n    var Tag = this.tag;\n\n    if (children && this.disabled) {\n      return children.length <= 1 && this.slim ? this.normalizeOwnChildren(children)[0] : h(Tag, [this.normalizeOwnChildren(children)]);\n    } else {\n      return this.slim ? h() : h(Tag, {\n        class: {\n          'v-portal': true\n        },\n        style: {\n          display: 'none'\n        },\n        key: 'v-portal-placeholder'\n      });\n    }\n  }\n});\nvar PortalTarget = Vue.extend({\n  name: 'portalTarget',\n  props: {\n    multiple: {\n      type: Boolean,\n      default: false\n    },\n    name: {\n      type: String,\n      required: true\n    },\n    slim: {\n      type: Boolean,\n      default: false\n    },\n    slotProps: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    },\n    transition: {\n      type: [String, Object, Function]\n    }\n  },\n  data: function data() {\n    return {\n      transports: wormhole.transports,\n      firstRender: true\n    };\n  },\n  created: function created() {\n    var _this = this;\n\n    this.$nextTick(function () {\n      wormhole.registerTarget(_this.name, _this);\n    });\n  },\n  watch: {\n    ownTransports: function ownTransports() {\n      this.$emit('change', this.children().length > 0);\n    },\n    name: function name(newVal, oldVal) {\n      /**\r\n       * TODO\r\n       * This should warn as well ...\r\n       */\n      wormhole.unregisterTarget(oldVal);\n      wormhole.registerTarget(newVal, this);\n    }\n  },\n  mounted: function mounted() {\n    var _this2 = this;\n\n    if (this.transition) {\n      this.$nextTick(function () {\n        // only when we have a transition, because it causes a re-render\n        _this2.firstRender = false;\n      });\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    wormhole.unregisterTarget(this.name);\n  },\n  computed: {\n    ownTransports: function ownTransports() {\n      var transports = this.transports[this.name] || [];\n\n      if (this.multiple) {\n        return transports;\n      }\n\n      return transports.length === 0 ? [] : [transports[transports.length - 1]];\n    },\n    passengers: function passengers() {\n      return combinePassengers(this.ownTransports, this.slotProps);\n    }\n  },\n  methods: {\n    // can't be a computed prop because it has to \"react\" to $slot changes.\n    children: function children() {\n      return this.passengers.length !== 0 ? this.passengers : this.$scopedSlots.default ? this.$scopedSlots.default(this.slotProps) : this.$slots.default || [];\n    },\n    // can't be a computed prop because it has to \"react\" to this.children().\n    noWrapper: function noWrapper() {\n      var noWrapper = this.slim && !this.transition;\n\n      if (noWrapper && this.children().length > 1) {\n        console.warn('[portal-vue]: PortalTarget with `slim` option received more than one child element.');\n      }\n\n      return noWrapper;\n    }\n  },\n  render: function render(h) {\n    var noWrapper = this.noWrapper();\n    var children = this.children();\n    var Tag = this.transition || this.tag;\n    return noWrapper ? children[0] : this.slim && !Tag ? h() : h(Tag, {\n      props: {\n        // if we have a transition component, pass the tag if it exists\n        tag: this.transition && this.tag ? this.tag : undefined\n      },\n      class: {\n        'vue-portal-target': true\n      }\n    }, children);\n  }\n});\nvar _id$1 = 0;\nvar portalProps = ['disabled', 'name', 'order', 'slim', 'slotProps', 'tag', 'to'];\nvar targetProps = ['multiple', 'transition'];\nvar MountingPortal = Vue.extend({\n  name: 'MountingPortal',\n  inheritAttrs: false,\n  props: {\n    append: {\n      type: [Boolean, String]\n    },\n    bail: {\n      type: Boolean\n    },\n    mountTo: {\n      type: String,\n      required: true\n    },\n    // Portal\n    disabled: {\n      type: Boolean\n    },\n    // name for the portal\n    name: {\n      type: String,\n      default: function _default() {\n        return 'mounted_' + String(_id$1++);\n      }\n    },\n    order: {\n      type: Number,\n      default: 0\n    },\n    slim: {\n      type: Boolean\n    },\n    slotProps: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    tag: {\n      type: String,\n      default: 'DIV'\n    },\n    // name for the target\n    to: {\n      type: String,\n      default: function _default() {\n        return String(Math.round(Math.random() * 10000000));\n      }\n    },\n    // Target\n    multiple: {\n      type: Boolean,\n      default: false\n    },\n    targetSlim: {\n      type: Boolean\n    },\n    targetSlotProps: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    targetTag: {\n      type: String,\n      default: 'div'\n    },\n    transition: {\n      type: [String, Object, Function]\n    }\n  },\n  created: function created() {\n    if (typeof document === 'undefined') return;\n    var el = document.querySelector(this.mountTo);\n\n    if (!el) {\n      console.error(\"[portal-vue]: Mount Point '\".concat(this.mountTo, \"' not found in document\"));\n      return;\n    }\n\n    var props = this.$props; // Target already exists\n\n    if (wormhole.targets[props.name]) {\n      if (props.bail) {\n        console.warn(\"[portal-vue]: Target \".concat(props.name, \" is already mounted.\\n        Aborting because 'bail: true' is set\"));\n      } else {\n        this.portalTarget = wormhole.targets[props.name];\n      }\n\n      return;\n    }\n\n    var append = props.append;\n\n    if (append) {\n      var type = typeof append === 'string' ? append : 'DIV';\n      var mountEl = document.createElement(type);\n      el.appendChild(mountEl);\n      el = mountEl;\n    } // get props for target from $props\n    // we have to rename a few of them\n\n\n    var _props = pick(this.$props, targetProps);\n\n    _props.slim = this.targetSlim;\n    _props.tag = this.targetTag;\n    _props.slotProps = this.targetSlotProps;\n    _props.name = this.to;\n    this.portalTarget = new PortalTarget({\n      el: el,\n      parent: this.$parent || this,\n      propsData: _props\n    });\n  },\n  beforeDestroy: function beforeDestroy() {\n    var target = this.portalTarget;\n\n    if (this.append) {\n      var el = target.$el;\n      el.parentNode.removeChild(el);\n    }\n\n    target.$destroy();\n  },\n  render: function render(h) {\n    if (!this.portalTarget) {\n      console.warn(\"[portal-vue] Target wasn't mounted\");\n      return h();\n    } // if there's no \"manual\" scoped slot, so we create a <Portal> ourselves\n\n\n    if (!this.$scopedSlots.manual) {\n      var props = pick(this.$props, portalProps);\n      return h(Portal, {\n        props: props,\n        attrs: this.$attrs,\n        on: this.$listeners,\n        scopedSlots: this.$scopedSlots\n      }, this.$slots.default);\n    } // else, we render the scoped slot\n\n\n    var content = this.$scopedSlots.manual({\n      to: this.to\n    }); // if user used <template> for the scoped slot\n    // content will be an array\n\n    if (Array.isArray(content)) {\n      content = content[0];\n    }\n\n    if (!content) return h();\n    return content;\n  }\n});\n\nfunction install(Vue$$1) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Vue$$1.component(options.portalName || 'Portal', Portal);\n  Vue$$1.component(options.portalTargetName || 'PortalTarget', PortalTarget);\n  Vue$$1.component(options.MountingPortalName || 'MountingPortal', MountingPortal);\n}\n\nvar index = {\n  install: install\n};\nexports.default = index;\nexports.Portal = Portal;\nexports.PortalTarget = PortalTarget;\nexports.MountingPortal = MountingPortal;\nexports.Wormhole = wormhole;","map":{"version":3,"mappings":"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","names":["inBrowser","window","freeze","item","Array","isArray","_typeof","Object","combinePassengers","transports","slotProps","reduce","passengers","transport","temp","newPassengers","concat","stableSort","array","compareFn","map","v","idx","sort","a","b","c","pick","obj","keys","acc","key","hasOwnProperty","targets","sources","Wormhole","Vue","extend","data","trackInstances","methods","open","to","from","order","Infinity","newTransport","indexOf","set","currentIndex","$_getTransportIndex","newTransports","slice","push","close","force","index","splice","registerTarget","target","vm","console","warn","$set","unregisterTarget","$delete","registerSource","source","unregisterSource","hasTarget","hasSource","hasContentFor","length","i","wormhole","_id","name","props","disabled","type","Boolean","String","default","Number","slim","tag","Math","round","random","created","$nextTick","_this","mounted","sendUpdate","updated","clear","beforeDestroy","watch","newValue","oldValue","closer","normalizeSlots","$scopedSlots","$slots","normalizeOwnChildren","children","slotContent","render","h","Tag","class","style","display","multiple","required","transition","Function","firstRender","ownTransports","$emit","newVal","oldVal","_this2","computed","noWrapper","undefined","portalProps","targetProps","inheritAttrs","append","bail","mountTo","targetSlim","targetSlotProps","targetTag","document","el","querySelector","error","$props","portalTarget","mountEl","createElement","appendChild","_props","PortalTarget","parent","$parent","propsData","$el","parentNode","removeChild","$destroy","manual","Portal","attrs","$attrs","on","$listeners","scopedSlots","content","install","options","component","portalName","portalTargetName","MountingPortalName","MountingPortal"],"sources":["../src/utils/index.ts","../src/components/wormhole.ts","../src/components/portal.tsx","../src/components/portal-target.tsx","../src/components/mounting-portal.tsx","../src/index.ts"],"sourcesContent":["import { VNode } from 'vue'\nimport { Transport } from '../types'\n\nexport const inBrowser = typeof window !== 'undefined'\n\nexport function freeze<R>(item: R[]): ReadonlyArray<R> {\n  if (Array.isArray(item) || typeof item === 'object') {\n    return Object.freeze(item)\n  }\n  return item\n}\n\nexport function combinePassengers(\n  transports: Transport[],\n  slotProps = {}\n): Array<VNode> {\n  return transports.reduce(\n    (passengers, transport) => {\n      const temp = transport.passengers[0]\n      const newPassengers =\n        typeof temp === 'function'\n          ? (temp(slotProps) as VNode[])\n          : (transport.passengers as VNode[])\n      return passengers.concat(newPassengers)\n    },\n    [] as Array<VNode>\n  )\n}\n\nexport function stableSort<T>(array: T[], compareFn: Function) {\n  return array\n    .map((v: T, idx: number) => {\n      return [idx, v] as [number, T]\n    })\n    .sort(function(a, b) {\n      return compareFn(a[1], b[1]) || a[0] - b[0]\n    })\n    .map(c => c[1])\n}\n\nexport function pick<T extends object, K extends keyof T>(\n  obj: T,\n  keys: K[]\n): Pick<T, K> {\n  return keys.reduce(\n    (acc, key) => {\n      if (obj.hasOwnProperty(key)) {\n        acc[key] = obj[key]\n      }\n      return acc\n    },\n    {} as Pick<T, K>\n  )\n}\n","import Vue from 'vue'\nimport { freeze, inBrowser, stableSort } from '../utils'\nimport {\n  Transports,\n  Transport,\n  TransportInput,\n  TransportVector,\n  VMRegister,\n} from '../types'\n\nconst transports: Transports = {}\nconst targets: VMRegister = {}\nconst sources: VMRegister = {}\n\nexport const Wormhole = Vue.extend({\n  data: () => ({\n    transports,\n    targets,\n    sources,\n    trackInstances: inBrowser,\n  }),\n  methods: {\n    open(transport: TransportInput) {\n      if (!inBrowser) return\n      const { to, from, passengers, order = Infinity } = transport\n      if (!to || !from || !passengers) return\n\n      const newTransport = {\n        to,\n        from,\n        passengers: freeze<object>(passengers),\n        order,\n      } as Transport\n      const keys = Object.keys(this.transports)\n\n      if (keys.indexOf(to) === -1) {\n        Vue.set(this.transports, to, [])\n      }\n\n      const currentIndex = this.$_getTransportIndex(newTransport)\n      // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays\n      const newTransports = this.transports[to].slice(0)\n      if (currentIndex === -1) {\n        newTransports.push(newTransport)\n      } else {\n        newTransports[currentIndex] = newTransport\n      }\n\n      this.transports[to] = stableSort<Transport>(\n        newTransports,\n        (a: Transport, b: Transport) => a.order - b.order\n      )\n    },\n\n    close(transport: TransportVector, force = false) {\n      const { to, from } = transport\n      if (!to || (!from && force === false)) return\n      if (!this.transports[to]) {\n        return\n      }\n\n      if (force) {\n        this.transports[to] = []\n      } else {\n        const index = this.$_getTransportIndex(transport)\n        if (index >= 0) {\n          // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays\n          const newTransports = this.transports[to].slice(0)\n          newTransports.splice(index, 1)\n          this.transports[to] = newTransports\n        }\n      }\n    },\n    registerTarget(target: string, vm: Vue, force?: boolean): void {\n      if (!inBrowser) return\n      if (this.trackInstances && !force && this.targets[target]) {\n        console.warn(`[portal-vue]: Target ${target} already exists`)\n      }\n      this.$set(this.targets, target, Object.freeze([vm]))\n    },\n    unregisterTarget(target: string) {\n      this.$delete(this.targets, target)\n    },\n    registerSource(source: string, vm: Vue, force?: boolean): void {\n      if (!inBrowser) return\n      if (this.trackInstances && !force && this.sources[source]) {\n        console.warn(`[portal-vue]: source ${source} already exists`)\n      }\n      this.$set(this.sources, source, Object.freeze([vm]))\n    },\n    unregisterSource(source: string) {\n      this.$delete(this.sources, source)\n    },\n    hasTarget(to: string) {\n      return !!(this.targets[to] && this.targets[to][0])\n    },\n    hasSource(to: string) {\n      return !!(this.sources[to] && this.sources[to][0])\n    },\n    hasContentFor(to: string) {\n      return !!this.transports[to] && !!this.transports[to].length\n    },\n    // Internal\n    $_getTransportIndex({ to, from }: TransportVector): number {\n      for (const i in this.transports[to]) {\n        if (this.transports[to][i].from === from) {\n          return +i\n        }\n      }\n      return -1\n    },\n  },\n})\n\nconst wormhole = new Wormhole(transports)\nexport { wormhole }\n","import Vue from 'vue'\nimport { VNode } from 'vue'\nimport { TransportInput, TransportVector } from '../types'\nimport { wormhole } from './wormhole'\n\nlet _id = 1\n\nexport default Vue.extend({\n  name: 'portal',\n  props: {\n    disabled: { type: Boolean },\n    name: { type: String, default: () => String(_id++) },\n    order: { type: Number, default: 0 },\n    slim: { type: Boolean },\n    slotProps: { type: Object, default: () => ({}) },\n    tag: { type: String, default: 'DIV' },\n    to: {\n      type: String,\n      default: () => String(Math.round(Math.random() * 10000000)),\n    },\n  },\n  created() {\n    this.$nextTick(() => {\n      wormhole.registerSource(this.name, this)\n    })\n  },\n  mounted() {\n    if (!this.disabled) {\n      this.sendUpdate()\n    }\n  },\n\n  updated() {\n    if (this.disabled) {\n      this.clear()\n    } else {\n      this.sendUpdate()\n    }\n  },\n\n  beforeDestroy() {\n    wormhole.unregisterSource(this.name)\n    this.clear()\n  },\n  watch: {\n    to(newValue: string, oldValue: string): void {\n      oldValue && oldValue !== newValue && this.clear(oldValue)\n      this.sendUpdate()\n    },\n  },\n\n  methods: {\n    clear(target?: string) {\n      const closer: TransportVector = {\n        from: this.name,\n        to: target || this.to,\n      }\n      wormhole.close(closer)\n    },\n    normalizeSlots(): Function[] | VNode[] | undefined {\n      return this.$scopedSlots.default\n        ? [this.$scopedSlots.default]\n        : this.$slots.default\n    },\n    normalizeOwnChildren(children: VNode[] | Function): VNode[] {\n      return typeof children === 'function'\n        ? children(this.slotProps)\n        : children\n    },\n    sendUpdate() {\n      const slotContent = this.normalizeSlots()\n      if (slotContent) {\n        const transport: TransportInput = {\n          from: this.name,\n          to: this.to,\n          passengers: [...slotContent],\n          order: this.order,\n        }\n        wormhole.open(transport)\n      } else {\n        this.clear()\n      }\n    },\n  },\n\n  render(h): VNode {\n    const children: VNode[] | Function =\n      this.$slots.default || this.$scopedSlots.default || []\n    const Tag = this.tag\n    if (children && this.disabled) {\n      return children.length <= 1 && this.slim ? (\n        this.normalizeOwnChildren(children)[0]\n      ) : (\n        <Tag>{this.normalizeOwnChildren(children)}</Tag>\n      )\n    } else {\n      return this.slim\n        ? h()\n        : h(Tag, {\n            class: { 'v-portal': true },\n            style: { display: 'none' },\n            key: 'v-portal-placeholder',\n          })\n    }\n  },\n})\n","import Vue from 'vue'\nimport { VNode, PropOptions } from 'vue'\nimport { combinePassengers } from '@/utils'\nimport { Transport, PropWithComponent } from '../types'\n\nimport { wormhole } from '@/components/wormhole'\n\nexport default Vue.extend({\n  name: 'portalTarget',\n  props: {\n    multiple: { type: Boolean, default: false },\n    name: { type: String, required: true },\n    slim: { type: Boolean, default: false },\n    slotProps: { type: Object, default: () => ({}) },\n    tag: { type: String, default: 'div' },\n    transition: { type: [String, Object, Function] } as PropOptions<\n      PropWithComponent\n    >,\n  },\n  data() {\n    return {\n      transports: wormhole.transports,\n      firstRender: true,\n    }\n  },\n  created() {\n    this.$nextTick(() => {\n      wormhole.registerTarget(this.name, this)\n    })\n  },\n  watch: {\n    ownTransports() {\n      this.$emit('change', this.children().length > 0)\n    },\n    name(newVal, oldVal) {\n      /**\n       * TODO\n       * This should warn as well ...\n       */\n      wormhole.unregisterTarget(oldVal)\n      wormhole.registerTarget(newVal, this)\n    },\n  },\n  mounted() {\n    if (this.transition) {\n      this.$nextTick(() => {\n        // only when we have a transition, because it causes a re-render\n        this.firstRender = false\n      })\n    }\n  },\n  beforeDestroy() {\n    wormhole.unregisterTarget(this.name)\n  },\n\n  computed: {\n    ownTransports(): Transport[] {\n      const transports: Transport[] = this.transports[this.name] || []\n      if (this.multiple) {\n        return transports\n      }\n      return transports.length === 0 ? [] : [transports[transports.length - 1]]\n    },\n    passengers(): VNode[] {\n      return combinePassengers(this.ownTransports, this.slotProps)\n    },\n  },\n\n  methods: {\n    // can't be a computed prop because it has to \"react\" to $slot changes.\n    children(): VNode[] {\n      return this.passengers.length !== 0\n        ? this.passengers\n        : this.$scopedSlots.default\n        ? (this.$scopedSlots.default(this.slotProps) as VNode[])\n        : this.$slots.default || []\n    },\n    // can't be a computed prop because it has to \"react\" to this.children().\n    noWrapper() {\n      const noWrapper = this.slim && !this.transition\n      if (noWrapper && this.children().length > 1) {\n        console.warn(\n          '[portal-vue]: PortalTarget with `slim` option received more than one child element.'\n        )\n      }\n      return noWrapper\n    },\n  },\n  render(h): VNode {\n    const noWrapper = this.noWrapper()\n    const children = this.children()\n    const Tag = this.transition || this.tag\n\n    return noWrapper\n      ? children[0]\n      : this.slim && !Tag\n      ? h()\n      : h(\n          Tag,\n          {\n            props: {\n              // if we have a transition component, pass the tag if it exists\n              tag: this.transition && this.tag ? this.tag : undefined,\n            },\n            class: { 'vue-portal-target': true },\n          },\n\n          children\n        )\n  },\n})\n","import Vue from 'vue'\nimport { VNode, VueConstructor, PropOptions } from 'vue'\nimport Portal from './portal'\nimport PortalTarget from './portal-target'\nimport { wormhole } from './wormhole'\nimport { pick } from '@/utils'\n\nimport { PropWithComponent } from '../types'\n\nlet _id = 0\n\nexport type withPortalTarget = VueConstructor<\n  Vue & {\n    portalTarget: any\n  }\n>\n\nconst portalProps = [\n  'disabled',\n  'name',\n  'order',\n  'slim',\n  'slotProps',\n  'tag',\n  'to',\n]\n\nconst targetProps = ['multiple', 'transition']\n\nexport default (Vue as withPortalTarget).extend({\n  name: 'MountingPortal',\n  inheritAttrs: false,\n  props: {\n    append: { type: [Boolean, String] },\n    bail: {\n      type: Boolean,\n    },\n    mountTo: { type: String, required: true },\n\n    // Portal\n    disabled: { type: Boolean },\n    // name for the portal\n    name: {\n      type: String,\n      default: () => 'mounted_' + String(_id++),\n    },\n    order: { type: Number, default: 0 },\n    slim: { type: Boolean },\n    slotProps: { type: Object, default: () => ({}) },\n    tag: { type: String, default: 'DIV' },\n    // name for the target\n    to: {\n      type: String,\n      default: () => String(Math.round(Math.random() * 10000000)),\n    },\n\n    // Target\n    multiple: { type: Boolean, default: false },\n    targetSlim: { type: Boolean },\n    targetSlotProps: { type: Object, default: () => ({}) },\n    targetTag: { type: String, default: 'div' },\n    transition: { type: [String, Object, Function] } as PropOptions<\n      PropWithComponent\n    >,\n  },\n  created() {\n    if (typeof document === 'undefined') return\n    let el: HTMLElement | null = document.querySelector(this.mountTo)\n\n    if (!el) {\n      console.error(\n        `[portal-vue]: Mount Point '${this.mountTo}' not found in document`\n      )\n      return\n    }\n\n    const props = this.$props\n\n    // Target already exists\n    if (wormhole.targets[props.name]) {\n      if (props.bail) {\n        console.warn(`[portal-vue]: Target ${props.name} is already mounted.\n        Aborting because 'bail: true' is set`)\n      } else {\n        this.portalTarget = wormhole.targets[props.name]\n      }\n      return\n    }\n\n    const { append } = props\n    if (append) {\n      const type = typeof append === 'string' ? append : 'DIV'\n      const mountEl = document.createElement(type)\n      el.appendChild(mountEl)\n      el = mountEl\n    }\n\n    // get props for target from $props\n    // we have to rename a few of them\n    const _props = pick(this.$props, targetProps)\n    _props.slim = this.targetSlim\n    _props.tag = this.targetTag\n    _props.slotProps = this.targetSlotProps\n    _props.name = this.to\n\n    this.portalTarget = new PortalTarget({\n      el,\n      parent: this.$parent || this,\n      propsData: _props,\n    })\n  },\n\n  beforeDestroy() {\n    const target = this.portalTarget\n    if (this.append) {\n      const el = target.$el\n      el.parentNode.removeChild(el)\n    }\n    target.$destroy()\n  },\n\n  render(h): VNode {\n    if (!this.portalTarget) {\n      console.warn(\"[portal-vue] Target wasn't mounted\")\n      return h()\n    }\n\n    // if there's no \"manual\" scoped slot, so we create a <Portal> ourselves\n    if (!this.$scopedSlots.manual) {\n      const props = pick(this.$props, portalProps)\n      return h(\n        Portal,\n        {\n          props: props,\n          attrs: this.$attrs,\n          on: this.$listeners,\n          scopedSlots: this.$scopedSlots,\n        },\n        this.$slots.default\n      )\n    }\n\n    // else, we render the scoped slot\n    let content: VNode = (this.$scopedSlots.manual({\n      to: this.to,\n    }) as unknown) as VNode\n\n    // if user used <template> for the scoped slot\n    // content will be an array\n    if (Array.isArray(content)) {\n      content = content[0]\n    }\n\n    if (!content) return h()\n\n    return content\n  },\n})\n","import Vue from 'vue'\nimport { VueConstructor } from 'vue'\nimport Portal from './components/portal'\nimport PortalTarget from './components/portal-target'\nimport MountingPortal from './components/mounting-portal'\nimport { wormhole as Wormhole } from './components/wormhole'\n\ndeclare global {\n  interface Window {\n    Vue?: VueConstructor<Vue>\n  }\n}\n\nexport interface PluginOptions {\n  portalName?: string\n  portalTargetName?: string\n  MountingPortalName?: string\n}\n\nfunction install(Vue: VueConstructor<Vue>, options: PluginOptions = {}) {\n  Vue.component(options.portalName || 'Portal', Portal)\n  Vue.component(options.portalTargetName || 'PortalTarget', PortalTarget)\n  Vue.component(options.MountingPortalName || 'MountingPortal', MountingPortal)\n}\nif (\n  // @ts-ignore\n  process.env.ROLLUP_BUILD_MODE === 'umd' &&\n  typeof window !== 'undefined' &&\n  window.Vue &&\n  window.Vue === Vue\n) {\n  window.Vue.use({ install: install })\n}\n\nexport default {\n  install,\n}\n\nexport { Portal, PortalTarget, MountingPortal, Wormhole }\n"]},"metadata":{},"sourceType":"script"}