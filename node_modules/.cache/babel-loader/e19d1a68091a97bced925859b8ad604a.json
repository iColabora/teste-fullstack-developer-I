{"ast":null,"code":"import { identity } from '../../../utils/identity';\nimport { isArray, isFunction, isObject, isString } from '../../../utils/inspect';\nimport { clone, keys } from '../../../utils/object';\nimport { startCase } from '../../../utils/string';\nimport { IGNORED_FIELD_KEYS } from './constants'; // Private function to massage field entry into common object format\n\nvar processField = function processField(key, value) {\n  var field = null;\n\n  if (isString(value)) {\n    // Label shortcut\n    field = {\n      key: key,\n      label: value\n    };\n  } else if (isFunction(value)) {\n    // Formatter shortcut\n    field = {\n      key: key,\n      formatter: value\n    };\n  } else if (isObject(value)) {\n    field = clone(value);\n    field.key = field.key || key;\n  } else if (value !== false) {\n    // Fallback to just key\n\n    /* istanbul ignore next */\n    field = {\n      key: key\n    };\n  }\n\n  return field;\n}; // We normalize fields into an array of objects\n// [ { key:..., label:..., ...}, {...}, ..., {..}]\n\n\nexport var normalizeFields = function normalizeFields(origFields, items) {\n  var fields = [];\n\n  if (isArray(origFields)) {\n    // Normalize array Form\n    origFields.filter(identity).forEach(function (f) {\n      if (isString(f)) {\n        fields.push({\n          key: f,\n          label: startCase(f)\n        });\n      } else if (isObject(f) && f.key && isString(f.key)) {\n        // Full object definition. We use assign so that we don't mutate the original\n        fields.push(clone(f));\n      } else if (isObject(f) && keys(f).length === 1) {\n        // Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\n        var key = keys(f)[0];\n        var field = processField(key, f[key]);\n\n        if (field) {\n          fields.push(field);\n        }\n      }\n    });\n  } // If no field provided, take a sample from first record (if exits)\n\n\n  if (fields.length === 0 && isArray(items) && items.length > 0) {\n    var sample = items[0];\n    keys(sample).forEach(function (k) {\n      if (!IGNORED_FIELD_KEYS[k]) {\n        fields.push({\n          key: k,\n          label: startCase(k)\n        });\n      }\n    });\n  } // Ensure we have a unique array of fields and that they have String labels\n\n\n  var memo = {};\n  return fields.filter(function (f) {\n    if (!memo[f.key]) {\n      memo[f.key] = true;\n      f.label = isString(f.label) ? f.label : startCase(f.key);\n      return true;\n    }\n\n    return false;\n  });\n};","map":{"version":3,"names":["identity","isArray","isFunction","isObject","isString","clone","keys","startCase","IGNORED_FIELD_KEYS","processField","key","value","field","label","formatter","normalizeFields","origFields","items","fields","filter","forEach","f","push","length","sample","k","memo"],"sources":["C:/Users/rayss/dev-fullstack-i/node_modules/bootstrap-vue/esm/components/table/helpers/normalize-fields.js"],"sourcesContent":["import { identity } from '../../../utils/identity';\nimport { isArray, isFunction, isObject, isString } from '../../../utils/inspect';\nimport { clone, keys } from '../../../utils/object';\nimport { startCase } from '../../../utils/string';\nimport { IGNORED_FIELD_KEYS } from './constants'; // Private function to massage field entry into common object format\n\nvar processField = function processField(key, value) {\n  var field = null;\n\n  if (isString(value)) {\n    // Label shortcut\n    field = {\n      key: key,\n      label: value\n    };\n  } else if (isFunction(value)) {\n    // Formatter shortcut\n    field = {\n      key: key,\n      formatter: value\n    };\n  } else if (isObject(value)) {\n    field = clone(value);\n    field.key = field.key || key;\n  } else if (value !== false) {\n    // Fallback to just key\n\n    /* istanbul ignore next */\n    field = {\n      key: key\n    };\n  }\n\n  return field;\n}; // We normalize fields into an array of objects\n// [ { key:..., label:..., ...}, {...}, ..., {..}]\n\n\nexport var normalizeFields = function normalizeFields(origFields, items) {\n  var fields = [];\n\n  if (isArray(origFields)) {\n    // Normalize array Form\n    origFields.filter(identity).forEach(function (f) {\n      if (isString(f)) {\n        fields.push({\n          key: f,\n          label: startCase(f)\n        });\n      } else if (isObject(f) && f.key && isString(f.key)) {\n        // Full object definition. We use assign so that we don't mutate the original\n        fields.push(clone(f));\n      } else if (isObject(f) && keys(f).length === 1) {\n        // Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\n        var key = keys(f)[0];\n        var field = processField(key, f[key]);\n\n        if (field) {\n          fields.push(field);\n        }\n      }\n    });\n  } // If no field provided, take a sample from first record (if exits)\n\n\n  if (fields.length === 0 && isArray(items) && items.length > 0) {\n    var sample = items[0];\n    keys(sample).forEach(function (k) {\n      if (!IGNORED_FIELD_KEYS[k]) {\n        fields.push({\n          key: k,\n          label: startCase(k)\n        });\n      }\n    });\n  } // Ensure we have a unique array of fields and that they have String labels\n\n\n  var memo = {};\n  return fields.filter(function (f) {\n    if (!memo[f.key]) {\n      memo[f.key] = true;\n      f.label = isString(f.label) ? f.label : startCase(f.key);\n      return true;\n    }\n\n    return false;\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}