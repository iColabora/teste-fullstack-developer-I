{"ast":null,"code":"var e = function () {\n  return (e = Object.assign || function (e) {\n    for (var t, r = 1, s = arguments.length; r < s; r++) for (var a in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);\n\n    return e;\n  }).apply(this, arguments);\n},\n    t = {\n  kebab: /-(\\w)/g,\n  styleProp: /:(.*)/,\n  styleList: /;(?![^(]*\\))/g\n};\n\nfunction r(e, t) {\n  return t ? t.toUpperCase() : \"\";\n}\n\nfunction s(e) {\n  for (var s, a = {}, c = 0, o = e.split(t.styleList); c < o.length; c++) {\n    var n = o[c].split(t.styleProp),\n        i = n[0],\n        l = n[1];\n    (i = i.trim()) && (\"string\" == typeof l && (l = l.trim()), a[(s = i, s.replace(t.kebab, r))] = l);\n  }\n\n  return a;\n}\n\nfunction a() {\n  for (var t, r, a = {}, c = arguments.length; c--;) for (var o = 0, n = Object.keys(arguments[c]); o < n.length; o++) switch (t = n[o]) {\n    case \"class\":\n    case \"style\":\n    case \"directives\":\n      if (Array.isArray(a[t]) || (a[t] = []), \"style\" === t) {\n        var i = void 0;\n        i = Array.isArray(arguments[c].style) ? arguments[c].style : [arguments[c].style];\n\n        for (var l = 0; l < i.length; l++) {\n          var y = i[l];\n          \"string\" == typeof y && (i[l] = s(y));\n        }\n\n        arguments[c].style = i;\n      }\n\n      a[t] = a[t].concat(arguments[c][t]);\n      break;\n\n    case \"staticClass\":\n      if (!arguments[c][t]) break;\n      void 0 === a[t] && (a[t] = \"\"), a[t] && (a[t] += \" \"), a[t] += arguments[c][t].trim();\n      break;\n\n    case \"on\":\n    case \"nativeOn\":\n      a[t] || (a[t] = {});\n\n      for (var p = 0, f = Object.keys(arguments[c][t] || {}); p < f.length; p++) r = f[p], a[t][r] ? a[t][r] = [].concat(a[t][r], arguments[c][t][r]) : a[t][r] = arguments[c][t][r];\n\n      break;\n\n    case \"attrs\":\n    case \"props\":\n    case \"domProps\":\n    case \"scopedSlots\":\n    case \"staticStyle\":\n    case \"hook\":\n    case \"transition\":\n      a[t] || (a[t] = {}), a[t] = e({}, arguments[c][t], a[t]);\n      break;\n\n    case \"slot\":\n    case \"key\":\n    case \"ref\":\n    case \"tag\":\n    case \"show\":\n    case \"keepAlive\":\n    default:\n      a[t] || (a[t] = arguments[c][t]);\n  }\n\n  return a;\n}\n\nexport { a as mergeData };","map":{"version":3,"mappings":"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","names":["pattern","kebab","styleProp","styleList","camelReplace","_substr","match","toUpperCase","parseStyle","style","str","styleMap","c","_a","split","_i","_b","key","val","trim","replace","mergeData","prop","event","mergeTarget","i","arguments","length","keys","Object","Array","isArray","j","s","concat","undefined"],"sources":["../src/index.ts"],"sourcesContent":["import { VNodeData } from \"vue\";\n\nconst pattern = {\n  kebab: /-(\\w)/g,\n  styleProp: /:(.*)/,\n\tstyleList: /;(?![^(]*\\))/g,\n} as const;\n\nfunction camelReplace(_substr: string, match: string) {\n  return match ? match.toUpperCase() : \"\";\n}\n\nfunction camelCase(str: string) {\n  return str.replace(pattern.kebab, camelReplace);\n}\n\nfunction parseStyle(style: string) {\n  let styleMap: Record<string, any> = {};\n\n  for (let s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp);\n    key = key.trim();\n    if (!key) {\n      continue;\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === \"string\") {\n      val = val.trim();\n    }\n    styleMap[camelCase(key)] = val;\n  }\n\n  return styleMap;\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nfunction mergeData(...vNodeData: VNodeData[]): VNodeData;\nfunction mergeData(): VNodeData {\n  let mergeTarget: VNodeData & Record<string, any> = {};\n  let i: number = arguments.length;\n  let prop: string;\n  let event: string;\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case \"class\":\n        case \"style\":\n        case \"directives\":\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = [];\n          }\n\n          if (prop === \"style\") {\n            let style: any[];\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style;\n            } else {\n              style = [arguments[i].style];\n            }\n            for (let j = 0; j < style.length; j++) {\n              let s = style[j];\n              if (typeof s === \"string\") {\n                style[j] = parseStyle(s);\n              }\n            }\n            arguments[i].style = style;\n          }\n\n          // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop]);\n          break;\n        // Space delimited string concatenation strategy\n        case \"staticClass\":\n          if (!arguments[i][prop]) {\n            break;\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = \"\";\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += \" \";\n          }\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case \"on\":\n        case \"nativeOn\":\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (mergeTarget[prop][event]) {\n              // Insert current iteration data in beginning of merged array.\n              mergeTarget[prop][event] = [].concat(\n                mergeTarget[prop][event],\n                arguments[i][prop][event]\n              );\n            } else {\n              // Straight assign.\n              mergeTarget[prop][event] = arguments[i][prop][event];\n            }\n          }\n          break;\n        // Object merge strategy\n        case \"attrs\":\n        case \"props\":\n        case \"domProps\":\n        case \"scopedSlots\":\n        case \"staticStyle\":\n        case \"hook\":\n        case \"transition\":\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] };\n          break;\n        // Reassignment strategy (no merge)\n        case \"slot\":\n        case \"key\":\n        case \"ref\":\n        case \"tag\":\n        case \"show\":\n        case \"keepAlive\":\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n      }\n    }\n  }\n\n  return mergeTarget;\n}\n\nexport { mergeData };\n"]},"metadata":{},"sourceType":"module"}